<meta charset="UTF-8">
<script>
/*
 * 전통적인 자바 스크립트로 콜백을 중첩해 나가다보면, 콜백 처리 코드가 복잡해진다 .. > 콜백 지옥
 	현재 프런트 앤드 분야에서 이 문제를 해결하기 위해 ES6 부터 Promise 가 도입되어 많이 사용됨
 	
 	전통적인 콜백 중첩 방식의 문제점
 	- 콜백 안에 콜백이 중첩되어 코드가 복잡하고 유지보수 성이 떨어짐 
 	[
 	addEventListener("load",function(){
 		$("#bt").click(function(){
				.... function > function > function > .... 			
 		});
 	});
 	]
 	- 예외 처리가 java 처럼 하나의 catch 블럭으로 통일될 수 없음,
 	
 	해결책 : Promise 의 도입 및 활용
 	
	Promise 란?
			비동기 처리 실행 시 미래에 대한 약속 처리 객체
			
	Promise 객체의 상태값
		Promise 는 미래의 비동기 작업 업무의 상태를 보관할 수 있는데 아래와 같이 3가지 형태의 값을 가짐
			ㄴ pending : 아직 완료 되지 않은 상태(default)
			ㄴ fulfilled : 비동기 업무가 성공했을때 갖는 값
			ㄴ rejected : 비동기 업무가 실패했을때 갖는 값
 */

	let p=new Promise(function(resolve,reject){	// 앞 매게변수 : Promise 의 상태값을 fulfilled로 , 뒤 매게변수: rejected 로 놓을 수 있는 역활
 		// 비동기로 처리하고픈 코드 작성...
 		
 		setTimeout(function(){
 			resolve();
 		},1000); 
 		
 		// 만일 비동기 요청의 내용이 네트워크 작업일 경우 ??
 		// 서버의 응답 정보를 성공적으로 가져왔는지 , 실패하였는지 따져보아야한다.
 		

 						//첫번째 매게변수로 전달된 함수를 호출했으므로 , Promise 의 상태를 fulfilled로 놓게됨
 						//resolve()를 호출하면 비동기 코드가 완료 되었을때 Promise 가 보유한 then() 메서드를 호출하게 됨..
 						//reject()를 호출하면 비동기 코드가 완료 되었을때 Promise 가 보유한 catch() 메서드를 호출하게 됨..

 						
 	});
 	
 
 	p.then(function(){
 		console.log("비동기 업무가 성공 되었네요");
 	});
 	
 	p.catch(function(){
 		console.log("비동기 업무가 실패 되었네요");
 	});
 	
 /*
 	console.log("A");
 	setTimeout(function(){
 		console.log("C");
 	},1000);
 	console.log("B");
 	
 	setTimeout(function(){})	비동기 방식 실행결과 ABC
 */


</script>